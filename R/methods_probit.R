#' @title The \code{probit} class and some basic methods
#'
#' @name probit-class
#' @description
#' Objects of class \code{probit} as generated by \code{\link{probit}} is a list with entries as specified below.
#' \describe{
#'   \item{\code{call}}{Function call.}
#'   \item{\code{response.name}}{Name of response in internal representation.}
#'   \item{\code{item.name}}{Name of item identifier in the model formula.}
#'   \item{\code{items.interval}}{Character vector with names of interval responses.}
#'   \item{\code{items.ordinal}}{Character vector with names of ordinal responses.}
#'   \item{\code{subject}}{Name of subject identifier.}
#'   \item{\code{random}}{List of mean models for the random effects.}
#'   \item{\code{dependence}}{Text string (\code{marginal} or \code{joint}) specifying the used correlation structure.}
#'   \item{\code{m.fixed}}{\code{\link[biglm]{biglm}}-object with joint fit of fixed effects. Note that test and confidence intervals on this object does not make direct sense.}
#'   \item{\code{sigma2}}{List with estimated variances for the interval responses.}
#'   \item{\code{eta}}{List with estimated threshold parameters for the ordinal responses.}
#'   \item{\code{m.random}}{List of \code{\link[stats]{lm}}-objects for mean models on the random effects.}
#'   \item{\code{Gamma}}{Cholesky factor of estimated inverse variance of random effects.}
#'   \item{\code{mu}}{Matrix (subjects, q) of estimated approximate conditional means for the random effects, where q = number of random effects.}
#'   \item{\code{psi}}{Matrix (subjects, q*(q+1)/2) of estimated Cholesky factors of approximate inverse conditional variances for the random effects.}
#'   \item{\code{B}}{Number of replications for each subject in Monte-Carlo computation in minimization step.}
#'   \item{\code{BB}}{Number of replications for each subject in Monte-Carlo computation in maximization step.}
#'   \item{\code{F1}}{Vector with subject-wise \code{F1}-values from last minimization step.}
#'   \item{\code{pvalue}}{p-value from latest T-test comparing the stochastic optimization.}
#'   \item{\code{iter}}{Number of minimization-maximization steps.}
#'   \item{\code{code}}{Iteration status: 0=iterations halted due to p-value, 1=iterations reached maximum iterations.}
#'   \item{\code{data}}{Tibble with dataset analyzed.}
#' }
#'
#' @param x Object of class \code{probit}.
#' @param BB Number of simulations per subject in \code{anova}. If \code{NULL}, then \code{BB} is taken from \code{x}.
#' @param digits Number of digits in print of \code{probit_anova} object. Defaults to \code{digits=4}.
#'
#' @note \code{anova} re-simulates the underlying responses and random
#' effects for the fixed effects model. Hence the output of the top part
#' of anova table is stochastic.
#'
#' @rdname probit-class
#' @export
print.probit <- function(x) {
  cat("Probit regression with",length(x$items.interval),"interval items and",length(x$items.ordinal),"ordinal items\n")
  cat("Total approximative log(likelihood)=",-sum(x$F1),"\n")
}

#' @rdname probit-class
#' @export
summary.probit <- function(x) {
  cat("Probit regression with",length(x$items.interval),"interval items,",length(x$items.ordinal),"ordinal items, and",length(x$random),"random effects.\n")
  cat("\n")
  cat("Total approximative log(likelihood)=",-sum(x$F1),"via",paste0("(",x$B,",",x$BB,")"),"replications in minimization-maximization steps.\n")
  cat("\n")
  if (x$dependence=="marginal") {
    cat("Variance of random effects (fitted as jointly independent):\n")
  } else {
    cat("Variance of random effects (fitted as jointly dependent):\n")
  }
  print(solve(t(x$Gamma)%*%(x$Gamma)))
  cat("\n")
  if (length(x$items.interval)>0) {
    cat("Variances on interval items:\n")
    print(unlist(x$sigma2))
    cat("\n")
  }
  if (length(x$items.ordinal)>0) {
    cat("Threshold parameters for ordinal items:\n")
    print(x$eta)
    cat("\n")
  }
#  cat("Individual item regressions:\n")
#  print(x$regression)
}

#' @rdname probit-class
#' @export
anova.probit <- function(x,BB=NULL) {
  # fit lm-object in order to be able to extract ANOVA table

  # take parameters from object
  subjects   <- unique(x$data[[x$subject]])
  q          <- length(x$random)
  items      <- c(x$items.interval,x$items.ordinal)
  random.eff <- unlist(lapply(x$random,function(x){all.vars(x[[2]])}))
  if (is.null(BB)) BB <- x$BB

  # design matrix for Cholesky factor of inverse covariance in normal approximation
  Q <- matrix(0,q*q,q*(q+1)/2)
  Q[matrix(1:(q*q),q,q)[upper.tri(matrix(0,q,q),diag=TRUE)],] <- diag(nrow=q*(q+1)/2)

  # set-up data matrix with random input
  U <- as_tibble(cbind(rep(subjects,each=BB),matrix(0,length(subjects)*BB,q)),
                 .name_repair = "minimal")
  names(U) <- c(x$subject,random.eff)
  for (s in 1:length(subjects)) {
    U[U[[x$subject]]==subjects[s],-1] <- t(x$mu[s,] + solve(matrix(Q%*%x$psi[s,],q,q),matrix(rnorm(BB*q),q,BB)))
  }
  mydata <- full_join(as_tibble(x$data),U,by=x$subject)

  # simulate responses for ordinal variables
  for (i in x$items.ordinal) {
    ii  <- !is.na(mydata[[i]]); NN <- sum(ii)
    tmp <- tibble(factor(rep(i,NN),levels=items)); names(tmp) <- x$item.name
    my.offset <- predict_slim(x$m.fixed,bind_cols(mydata[ii,],tmp))
    # simulated underlying normal and insert in mydata
    tmp <- as.numeric(mydata[[i]][ii])
    mydata[,i] <- rep(as.numeric(NA),nrow(mydata))
    mydata[ii,i] <- my.offset + qnorm(
      pnorm(c(-Inf,x$eta[[i]])[tmp]-my.offset) +
        (pnorm(c(x$eta[[i]],Inf)[tmp]-my.offset) - pnorm(c(-Inf,x$eta[[i]])[tmp]-my.offset))*runif(NN)
    )
  }

  # linear regression
  mydata <- pivot_longer(mydata,all_of(items),names_to = x$item.name, values_to = x$response.name)
  m.lm <- lm(eval(substitute(update(formula(x$call),y~.),list(y=as.name(x$response.name)))),
             data=mydata)

  # extract and correct anova from fixed effect model
  my.anova <- as.data.frame(anova(m.lm))
  my.anova["Residuals","Df"] <- (m.lm$df.residual + sum(!is.na(m.lm$coefficients)))/BB - sum(!is.na(m.lm$coefficients))
  my.anova[,"Sum Sq"] <- my.anova[,"Sum Sq"]/BB
  my.anova[,"Mean Sq"] <- my.anova[,"Sum Sq"]/my.anova[,"Df"]
  my.anova[-nrow(my.anova),"F value"] <- my.anova[-nrow(my.anova),"Mean Sq"] / my.anova[nrow(my.anova),"Mean Sq"]
  my.anova[-nrow(my.anova),"Pr(>F)"] <- 1-pf(my.anova[-nrow(my.anova),"F value"],df1=my.anova[-nrow(my.anova),"Df"],df2=my.anova[nrow(my.anova),"Df"])
  my.anova <- cbind(variable=x$item.name,my.anova)
  # extract anova's for random effect models
  for (i in random.eff) {
    tmp <- cbind(variable=i,as.data.frame(anova(x$m.random[[i]])))
    rownames(tmp)[nrow(tmp)] <- paste0("Residuals.",i)
    my.anova <- rbind(my.anova,tmp)
  }

  # return
  return(structure(my.anova,class=c("probit_anova","data.frame")))
}

#' @rdname probit-class
#' @export
print.probit_anova <- function(x,digits=4) {
  if (!is.null(digits)) x[,-1] <- round(x[,-1],digits=digits)
  tmp <- rownames(x)
  x <- as.data.frame(apply(x,2,function(y){ifelse(is.na(y),".",as.character(y))})); rownames(x) <- tmp
  skip <- data.frame(V1=paste(rep("-",max(8,nchar(x$variable))),collapse=""),
                     V2=paste(rep("-",max(2,nchar(x$Df))),collapse=""),
                     V3=paste(rep("-",max(6,nchar(x$'Sum Sq'))),collapse=""),
                     V4=paste(rep("-",max(7,nchar(x$'Mean Sq'))),collapse=""),
                     V5=paste(rep("-",max(7,nchar(x$'F value'))),collapse=""),
                     V6=paste(rep("-",max(6,nchar(x$'Pr(>F)'))),collapse=""))
  rownames(skip) <- ""; colnames(skip) <- colnames(x)
  tmp <- which(c("",x$variable)!=c(x$variable,""))
  y <- skip; for (i in 2:length(tmp)) {
    rownames(skip) <- paste(c(" ",rownames(skip)),collapse="")
    y <- rbind(y,x[tmp[i-1]:(tmp[i]-1),],skip)
  }
  print(y)
}

# anova.probit <- function(x,y) {
#   # sanity check
#   if (!base::setequal(x$items,y$items)) stop("Models must be fitted on the same items")
#   # set-up tibble with results
#   res <- matrix(0,1+length(x$items),4)
#   colnames(res) <- c("LR.stat","df.fixed","df.random","Pr(>Chisq)")
#   res <- bind_cols(tibble(item=c("all.items",x$items)),as_tibble(res))
#   # extract likelihood ratio tests
#   pm <- ifelse(sum(sapply(x$regression,function(u){length(coef(u))}))+nrow(x$Gamma) >
#                sum(sapply(y$regression,function(u){length(coef(u))}))+nrow(y$Gamma),
#                1,-1)
#   for (i in 1:length(x$items)) {
#     tmp <- anova(x$regression[[i]],y$regression[[i]])
#     res$LR.stat[1+i]      <- tmp[2,"LR.stat"]
#     res$df.fixed[1+i]     <- tmp[2,"df"]
#     res$df.random[1+i]    <- pm*(nrow(x$Gamma)-nrow(y$Gamma))/length(x$items)
#     res$"Pr(>Chisq)"[1+i] <- 1-pchisq(res$LR.stat[1+i],df=res$df.fixed[1+i]+res$df.random[1+i])
#   }
#   # find overall likelihood ratio test
#   res$LR.stat[1]      <- sum(res$LR.stat[-1])
#   res$df.fixed[1]     <- sum(res$df.fixed[-1])
#   res$df.random[1]    <- sum(res$df.random[-1])
#   res$"Pr(>Chisq)"[1] <- 1-pchisq(res$LR.stat[1],df=res$df.fixed[1]+res$df.random[1])
#   # return result
#   res
# }
